[thrift官网](https://thrift.apache.org/) 

[acf](https://www.acwing.com/solution/content/170515/) 

## 过程

- 服务端编译main文件

```sh
cd thrift_lesson/match_system/src
thrift -r --gen cpp ../../thrift/match.thrift  # 生成cpp的thrift，后面是接口路径
mv gen-cpp/ match_server
mv match_server/Match_server.skeleton.cpp main.cpp
vim main.cpp
```

```diff
<@@ 35, 50> main.cpp
+++ return 0
+++ return 0
gg=G
```

```sh
g++ -c main.cpp match_server/*.cpp  # 编译main.cpp match_server下各种cpp
# 刚报错，进入修改一下引用文件路径
vim main.cpp # 第 4 行 match_server/Match.h
g++ -c main.cpp
g++ *.o -o main -lthrift  # 链接
./main # 运行但是没有输出
vim main.cpp # 增加输出
```

```diff
<@@ ., ., 52> main.cpp
+++ #include <iostream>
+++ using namespace std;
+++ cout << "Start Match Server" << endl;    // 在最后的server.server();前增加
```

```sh
g++ -c main.cpp  # 只是更改了main.cpp 只需要在编译该文件
g++ *.o -o main -lthrift  # 链接
./main
```

- 客户端，添加/删除用户

```sh
cd thrift_lesson/game/src
thrift -r --gen py ../../thrift/match.thrift
mv gen-py/ match_client
cd match_client/match
rm Match-remote  # (服务端)因为要实现客户端，因此可以删掉
cd ../..
vim client.py
```

源文件[地址](https://thrift.apache.org/tutorial/py.html#client) 

```py
from match_client.match import Match
from match_client.match.ttypes import User

from thrift import Thrift
from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol


def main():
    # Make socket
    # 在本地，localhost也可以改成127.0.0.1
    transport = TSocket.TSocket('localhost', 9090)
    
    # Buffering is critical. Raw sockets are very slow
    transport = TTransport.TBufferedTransport(transport)

    # Wrap in a protocol
    protocol = TBinaryProtocol.TBinaryProtocol(transport)
             
    # Create a client to use the protocol encoder
    client = Match.Client(protocol)

    # Connect!
    transport.open()

    user = User(1, 'yqy', 1500)
    client.add_user(user, '')

    # Close!
    transport.close()
if __name__ == '__main__':
    try:           
        main()
    except Thrift.TException as tx:
        print('%s' % tx.message)
```

- 服务端，实现匹配机制

```sh
cd thrift_lesson/match_system/src
vim main.cpp
```

```cpp
// main.cpp
// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <iostream>
#include "match_server/Match.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <vector>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::match_service;
using namespace std;

struct Task{
    User user;
    string type;
};

struct MessageQueue{
    queue<Task> q;
    mutex m;
    condition_variable cv;
}message_queue;

class Pool{
    public:
        void save_result(int a, int b){
            printf("Match Result: %d %d\n", a, b);
        }

        void match(){
            while (users.size() > 1){
                auto a = users[0], b = users[1];
                users.erase(users.begin());
                users.erase(users.begin());

                save_result(a.id, b.id);
            }
        }


        void add(User user){
            users.push_back(user);
        }

        void remove(User user){
            for (uint32_t i = 0; i < users.size(); i++)
                if (users[i].id == user.id){
                    users.erase(users.begin() + i);
                    break;
                }
        }

    private:
        vector<User> users;
}pool;


class MatchHandler : virtual public MatchIf {
 public:
  MatchHandler() {
    // Your initialization goes here
  }

  /**
   * user: 添加的用户信息
   * info: 附加信息
   * 在匹配池中添加一个名用户
   * 
   * @param user
   * @param info
   */
  int32_t add_user(const User& user, const std::string& info) {
    // Your implementation goes here
    printf("add_user\n");

    // 加锁
    unique_lock<mutex> lck(message_queue.m);
    message_queue.q.push({user, "add"});
    message_queue.cv.notify_all();

    return 0;
  }

  /**
   * user: 删除的用户信息
   * info: 附加信息
   * 从匹配池中删除一名用户
   * 
   * @param user
   * @param info
   */
  int32_t remove_user(const User& user, const std::string& info) {
    // Your implementation goes here
    printf("remove_user\n");
    
    // 加锁
    unique_lock<mutex> lck(message_queue.m);
    message_queue.q.push({user, "remove"});
    message_queue.cv.notify_all();
    
    return 0;
  }

};


void consume_task(){
    while(true){

        unique_lock<mutex> lck(message_queue.m);
        if (message_queue.q.empty()){
            message_queue.cv.wait(lck);
        }
        else {
            auto task = message_queue.q.front();
            message_queue.q.pop();
            lck.unlock();

            // do task
            if (task.type == "add") pool.add(task.user);
            else if (task.type == "remove") pool.remove(task.user);

            pool.match();
        }
    }
}

int main(int argc, char **argv) {
  int port = 9090;
  ::std::shared_ptr<MatchHandler> handler(new MatchHandler());
  ::std::shared_ptr<TProcessor> processor(new MatchProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

  cout << "Start Match Server" << endl;

  thread matching_thread(consume_task);

  server.serve();
  return 0;
}


```

```sh
g++ -c main.cpp
g++ *.o -o main -lthrift -pthread  # 同时用了线程
./main
```

#### 引用文件，将数据存储到服务器中

   ```sh
   # thrift_lesson/thrift/save.thrift  # 通过sava文件进行连接服务器, 存储地址/存储路径在save.thrift中
   md5sum <Enter> 输入密码 <Enter> <Ctrl + D> # 令牌是前8位
   cd thrift_lesson/match_system/src
   thrift -r --gen cpp ../../thrift/save.thrift
   mv gen-cpp/ save_client
   rm Save_server.skeleton.cpp  # 删除服务端，因为没用,否则生成两个main，cpp只能有一个main
   
   # 将 save-client 引入match_system的main中，调用client端
   ```

   [官网例子](https://thrift.apache.org/tutorial/cpp.html#client)

   将内容放入match_system/src/main.cpp

   ```diff
   +++ #include "save_client/Save.h"
   +++ #include <thrift/transport/TTransportUtils.h>
   +++ #include <thrift/transport/TSocket.h>
   
   +++ using namespace ::save_service;
   
   
   // 复制链接main所有, 放入本地main.cpp Pool.save_result.printf 后面
   // :set paste 然后粘贴接着 gg=G :set nopaste 修改ip，改成远端的服务器
   --- std::shared_ptr<TTransport> socket(new TSocket("localhost", 9090));
   +++ std::shared_ptr<TTransport> socket(new TSocket("123.57.67.128", 9090));
   +++  std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
   +++  std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
   ---  CalculatorClient client(protocol);
   +++  SaveClient client(protocol);
   +++
   +++  try {
   +++    transport->open();
   ---
   ---    client.ping();
   ---    cout << "ping()" << '\n';
   ---
   ---    cout << "1 + 1 = " << client.add(1, 1) << '\n';
   ---
   ---    Work work;
   ---    work.op = Operation::DIVIDE;
   ---    work.num1 = 1;
   ---    work.num2 = 0;
   ---
   ---    try {
   ---      client.calculate(1, work);
   ---      cout << "Whoa? We can divide by zero!" << '\n';
   ---    } catch (InvalidOperation& io) {
   ---      cout << "InvalidOperation: " << io.why << '\n';
   ---      // or using generated operator<<: cout << io << '\n';
   ---      // or by using std::exception native method what(): cout << io.what() << '\n';
   ---    }
   ---
   ---    work.op = Operation::SUBTRACT;
   ---    work.num1 = 15;
   ---    work.num2 = 10;
   ---    int32_t diff = client.calculate(1, work);
   ---    cout << "15 - 10 = " << diff << '\n';
   ---
   ---    // Note that C++ uses return by reference for complex types to avoid
   ---    // costly copy construction
   ---    SharedStruct ss;
   ---    client.getStruct(ss, 1);
   ---    cout << "Received log: " << ss << '\n';
          // client.save_data("acs_14657", "1b6889b0", a, b); // 用户名，密码（MD5前8位), 用户a， b
          int res = client.save_data("acs_14657", "1b6889b0", a, b);
          if (!res) puts("success!");
          else puts("failed!");
   +++    transport->close();
   +++  } catch (TException& tx) {
   +++    cout << "ERROR: " << tx.what() << '\n';
   +++  }
   ```

   完整的`main.cpp` 

   ```cpp
   // This autogenerated skeleton file illustrates how to build a server.
   // You should copy it to another filename to avoid overwriting it.
   
   #include "match_server/Match.h"
   #include "save_client/Save.h"
   #include <thrift/protocol/TBinaryProtocol.h>
   #include <thrift/server/TSimpleServer.h>
   #include <thrift/transport/TServerSocket.h>
   #include <thrift/transport/TBufferTransports.h>
   #include <thrift/transport/TTransportUtils.h>
   #include <thrift/transport/TSocket.h>
   
   #include <iostream>
   #include <thread>
   #include <mutex>
   #include <condition_variable>
   #include <queue>
   #include <vector>
   
   using namespace ::apache::thrift;
   using namespace ::apache::thrift::protocol;
   using namespace ::apache::thrift::transport;
   using namespace ::apache::thrift::server;
   
   using namespace ::save_service;
   using namespace ::match_service;
   using namespace std;
   
   struct Task{
       User user;
       string type;
   };
   
   struct MessageQueue{
       queue<Task> q;
       mutex m;
       condition_variable cv;
   }message_queue;
   
   class Pool{
       public:
           void save_result(int a, int b){
               printf("Match Result: %d %d\n", a, b);
   
               // std::shared_ptr<TTransport> socket(new TSocket("123.57.67.128", 9090));
               std::shared_ptr<TTransport> socket(new TSocket("123.57.67.128", 9090));
               std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
               std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
               SaveClient client(protocol);
   
               try {
                   transport->open();
                   client.save_data("acs_14657", "1b6889b0", a, b);
                   int res = client.save_data("acs_14657", "1b6889b0", a, b);
                   if (!res) puts("success!");
                   else puts("failed!");
                       transport->close();
               } catch (TException& tx) {
                   cout << "ERROR: " << tx.what() << '\n';
               }
           }
   
           void match(){
               while (users.size() > 1){
                   auto a = users[0], b = users[1];
                   users.erase(users.begin());
                   users.erase(users.begin());
   
                   save_result(a.id, b.id);
               }
           }
   
   
           void add(User user){
               users.push_back(user);
           }
   
           void remove(User user){
               for (uint32_t i = 0; i < users.size(); i++)
                   if (users[i].id == user.id){
                       users.erase(users.begin() + i);
                       break;
                   }
           }
   
       private:
           vector<User> users;
   }pool;
   
   
   class MatchHandler : virtual public MatchIf {
       public:
           MatchHandler() {
               // Your initialization goes here
           }
   
           /**
            * user: 添加的用户信息
            * info: 附加信息
            * 在匹配池中添加一个名用户
            * 
            * @param user
            * @param info
            */
           int32_t add_user(const User& user, const std::string& info) {
               // Your implementation goes here
               printf("add_user\n");
   
               // 加锁
               unique_lock<mutex> lck(message_queue.m);
               message_queue.q.push({user, "add"});
               message_queue.cv.notify_all();
   
               return 0;
           }
   
           /**
            * user: 删除的用户信息
            * info: 附加信息
            * 从匹配池中删除一名用户
            * 
            * @param user
            * @param info
            */
           int32_t remove_user(const User& user, const std::string& info) {
               // Your implementation goes here
               printf("remove_user\n");
   
               // 加锁
               unique_lock<mutex> lck(message_queue.m);
               message_queue.q.push({user, "remove"});
               message_queue.cv.notify_all();
   
               return 0;
           }
   
   };
   
   
   void consume_task(){
       while(true){
   
           unique_lock<mutex> lck(message_queue.m);
           if (message_queue.q.empty()){
               message_queue.cv.wait(lck);
           }
           else {
               auto task = message_queue.q.front();
               message_queue.q.pop();
               lck.unlock();
   
               // do task
               if (task.type == "add") pool.add(task.user);
               else if (task.type == "remove") pool.remove(task.user);
   
               pool.match();
           }
       }
   }
   
   int main(int argc, char **argv) {
       int port = 9090;
       ::std::shared_ptr<MatchHandler> handler(new MatchHandler());
       ::std::shared_ptr<TProcessor> processor(new MatchProcessor(handler));
       ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
       ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
       ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
   
       TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
   
       cout << "Start Match Server" << endl;
   
       thread matching_thread(consume_task);
   
       server.serve();
       return 0;
   }
   
   ```

   ```
   g++ -c save_client/*.cpp
   g++ -c main.cpp
   g++ *.o -o main -lthrift -pthread
   ./main
   ```

#### 优化匹配机制

修改main.cpp的`consume_task()` 函数

```diff
   void match(){
       while (users.size() > 1){
---        auto a = users[0], b = users[1];
---        users.erase(users.begin());
---        users.erase(users.begin());
---
---        save_result(a.id, b.id);
+++        sort(users.begin(), users.end(), [&](User& a, User b){
+++            return a.score < b.score;
+++        });
+++
+++        bool flag = true;
+++        for (uint32_t i = 1; i < users.size(); i++){
+++            auto a = users[i-1], b = users[i];
+++            if (b.score - a.score <= 50){
+++                users.erase(users.begin() + i - 1, users.begin() + i + 1);
+++                save_result(a.id, b.id);
+++
+++                flag = false;
+++                break;
+++            }
+++        }
+++        if (flag) break;
+++    }
+++}

   if (message_queue.q.empty()){
---    message_queue.cv.wait(lck);
+++    // message_queue.cv.wait(lck);
+++    lck.unlock();
+++    pool.match();
+++    sleep(1);
   }
```

完整`main.cpp` 

```cpp
// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "match_server/Match.h"
#include "save_client/Save.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/transport/TSocket.h>

#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <vector>
#include <unistd.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace ::save_service;
using namespace ::match_service;
using namespace std;

struct Task{
    User user;
    string type;
};

struct MessageQueue{
    queue<Task> q;
    mutex m;
    condition_variable cv;
}message_queue;

class Pool{
    public:
        void save_result(int a, int b){
            printf("Match Result: %d %d\n", a, b);

            // std::shared_ptr<TTransport> socket(new TSocket("123.57.67.128", 9090));
            std::shared_ptr<TTransport> socket(new TSocket("123.57.67.128", 9090));
            std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
            std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
            SaveClient client(protocol);

            try {
                transport->open();
                client.save_data("acs_14657", "1b6889b0", a, b);
                int res = client.save_data("acs_14657", "1b6889b0", a, b);
                if (!res) puts("success!");
                else puts("failed!");
                    transport->close();
            } catch (TException& tx) {
                cout << "ERROR: " << tx.what() << '\n';
            }
        }

        void match(){
            while (users.size() > 1){
                sort(users.begin(), users.end(), [&](User& a, User b){
                    return a.score < b.score;
                });

                bool flag = true;
                for (uint32_t i = 1; i < users.size(); i++){
                    auto a = users[i-1], b = users[i];
                    if (b.score - a.score <= 50){
                        users.erase(users.begin() + i - 1, users.begin() + i + 1);
                        save_result(a.id, b.id);

                        flag = false;
                        break;
                    }
                }
                if (flag) break;
            }
        }


        void add(User user){
            users.push_back(user);
        }

        void remove(User user){
            for (uint32_t i = 0; i < users.size(); i++)
                if (users[i].id == user.id){
                    users.erase(users.begin() + i);
                    break;
                }
        }

    private:
        vector<User> users;
}pool;


class MatchHandler : virtual public MatchIf {
    public:
        MatchHandler() {
            // Your initialization goes here
        }

        /**
         * user: 添加的用户信息
         * info: 附加信息
         * 在匹配池中添加一个名用户
         * 
         * @param user
         * @param info
         */
        int32_t add_user(const User& user, const std::string& info) {
            // Your implementation goes here
            printf("add_user\n");

            // 加锁
            unique_lock<mutex> lck(message_queue.m);
            message_queue.q.push({user, "add"});
            message_queue.cv.notify_all();

            return 0;
        }

        /**
         * user: 删除的用户信息
         * info: 附加信息
         * 从匹配池中删除一名用户
         * 
         * @param user
         * @param info
         */
        int32_t remove_user(const User& user, const std::string& info) {
            // Your implementation goes here
            printf("remove_user\n");

            // 加锁
            unique_lock<mutex> lck(message_queue.m);
            message_queue.q.push({user, "remove"});
            message_queue.cv.notify_all();

            return 0;
        }

};


void consume_task(){
    while(true){

        unique_lock<mutex> lck(message_queue.m);
        if (message_queue.q.empty()){
            // message_queue.cv.wait(lck);
            lck.unlock();
            pool.match();
            sleep(1);
        }
        else {
            auto task = message_queue.q.front();
            message_queue.q.pop();
            lck.unlock();

            // do task
            if (task.type == "add") pool.add(task.user);
            else if (task.type == "remove") pool.remove(task.user);

            pool.match();
        }
    }
}

int main(int argc, char **argv) {
    int port = 9090;
    ::std::shared_ptr<MatchHandler> handler(new MatchHandler());
    ::std::shared_ptr<TProcessor> processor(new MatchProcessor(handler));
    ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

    cout << "Start Match Server" << endl;

    thread matching_thread(consume_task);

    server.serve();
    return 0;
}


```

```sh
g++ -c main.cpp
g++ *.o -o main -lthrift -pthread
# 两个终端分别执行
# 服务端
~/homework/lesson_6/thrift_lesson/match_system/scr/main
#客户端
python3 ~/homework/lesson_6/thrift_lesson/game/src/client
```

```sh
# 客户端输入
add 1 1 1000
add 2 2 2000
add 3 3 999
add 4 4 3000
remove 2 2 2000
add 5 5 1999
add 6 6 2999
# 服务端返回
Start Match Server
add_user
add_user
add_user
Match Result: 3 1
success!
add_user
remove_user
add_user
add_user
Match Result: 6 4
success!
```

```
git add ~/homework/lesson_6/thrift_lesson/match_system/scr/main.cpp
git commit -m "match server:3.0 des-Match within a score difference of 50 points"
```

#### 多线程

[地址](https://github.com/apache/thrift/blob/master/tutorial/cpp/CppServer.cpp) 

代码变化 [Github](https://github.com/hueryan/thrift-frist-program/commit/692e3d8946c90cb85a5aa2c021166090533cb93d) [Gitee](https://gitee.com/hueryan/thrift-first-program/commit/d6582f7bc04a0afb803c0d0c29f1eafe48032b86) 

```sh
# copy 完，替换
:1,$s/Calculator/Match/g
```

```cpp
// 完整main.cpp
// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "match_server/Match.h"
#include "save_client/Save.h"
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/ThreadFactory.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/transport/TSocket.h>
#include <thrift/TToString.h>

#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <vector>
#include <unistd.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace ::save_service;
using namespace ::match_service;
using namespace std;

struct Task{
    User user;
    string type;
};

struct MessageQueue{
    queue<Task> q;
    mutex m;
    condition_variable cv;
}message_queue;

class Pool{
    public:
        void save_result(int a, int b){
            printf("Match Result: %d %d\n", a, b);

            // std::shared_ptr<TTransport> socket(new TSocket("123.57.67.128", 9090));
            std::shared_ptr<TTransport> socket(new TSocket("123.57.67.128", 9090));
            std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
            std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
            SaveClient client(protocol);

            try {
                transport->open();
                client.save_data("acs_14657", "1b6889b0", a, b);
                int res = client.save_data("acs_14657", "1b6889b0", a, b);
                if (!res) puts("success!");
                else puts("failed!");
                transport->close();
            } catch (TException& tx) {
                cout << "ERROR: " << tx.what() << '\n';
            }
        }

        void match(){
            while (users.size() > 1){
                sort(users.begin(), users.end(), [&](User& a, User b){
                        return a.score < b.score;
                        });

                bool flag = true;
                for (uint32_t i = 1; i < users.size(); i++){
                    auto a = users[i-1], b = users[i];
                    if (b.score - a.score <= 50){
                        users.erase(users.begin() + i - 1, users.begin() + i + 1);
                        save_result(a.id, b.id);

                        flag = false;
                        break;
                    }
                }
                if (flag) break;
            }
        }


        void add(User user){
            users.push_back(user);
        }

        void remove(User user){
            for (uint32_t i = 0; i < users.size(); i++)
                if (users[i].id == user.id){
                    users.erase(users.begin() + i);
                    break;
                }
        }

    private:
        vector<User> users;
}pool;


class MatchHandler : virtual public MatchIf {
    public:
        MatchHandler() {
            // Your initialization goes here
        }

        /**
         * user: 添加的用户信息
         * info: 附加信息
         * 在匹配池中添加一个名用户
         * 
         * @param user
         * @param info
         */
        int32_t add_user(const User& user, const std::string& info) {
            // Your implementation goes here
            printf("add_user\n");

            // 加锁
            unique_lock<mutex> lck(message_queue.m);
            message_queue.q.push({user, "add"});
            message_queue.cv.notify_all();

            return 0;
        }

        /**
         * user: 删除的用户信息
         * info: 附加信息
         * 从匹配池中删除一名用户
         * 
         * @param user
         * @param info
         */
        int32_t remove_user(const User& user, const std::string& info) {
            // Your implementation goes here
            printf("remove_user\n");

            // 加锁
            unique_lock<mutex> lck(message_queue.m);
            message_queue.q.push({user, "remove"});
            message_queue.cv.notify_all();

            return 0;
        }

};

class MatchCloneFactory : virtual public MatchIfFactory {
    public:
        ~MatchCloneFactory() override = default;
        MatchIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) override
        {
            std::shared_ptr<TSocket> sock = std::dynamic_pointer_cast<TSocket>(connInfo.transport);
            /*
            cout << "Incoming connection\n";
            cout << "\tSocketInfo: "  << sock->getSocketInfo() << "\n";
            cout << "\tPeerHost: "    << sock->getPeerHost() << "\n";
            cout << "\tPeerAddress: " << sock->getPeerAddress() << "\n";
            cout << "\tPeerPort: "    << sock->getPeerPort() << "\n";
            */
            return new MatchHandler;
        }
        void releaseHandler(MatchIf* handler) override {
            delete handler;
        }
};

void consume_task(){
    while(true){

        unique_lock<mutex> lck(message_queue.m);
        if (message_queue.q.empty()){
            // message_queue.cv.wait(lck);
            lck.unlock();
            pool.match();
            sleep(1);
        }
        else {
            auto task = message_queue.q.front();
            message_queue.q.pop();
            lck.unlock();

            // do task
            if (task.type == "add") pool.add(task.user);
            else if (task.type == "remove") pool.remove(task.user);

            pool.match();
        }
    }
}

int main(int argc, char **argv) {
    TThreadedServer server(
            std::make_shared<MatchProcessorFactory>(std::make_shared<MatchCloneFactory>()),
            std::make_shared<TServerSocket>(9090), //port
            std::make_shared<TBufferedTransportFactory>(),
            std::make_shared<TBinaryProtocolFactory>());


    cout << "Start Match Server" << endl;

    thread matching_thread(consume_task);

    server.serve();
    return 0;
}


```

```
g++ -c main.cpp
g++ *.o -o main -lthrift -pthread
./main
```

#### 增加匹配时间

代码变化 [Github](https://github.com/hueryan/thrift-frist-program/commit/b86ef343c202e1bbadb22d3109ef863bba462840) [Gitee](https://gitee.com/hueryan/thrift-first-program/commit/dacbab545a9487eb9ff8148223c36a3928cbd987) 

```cpp
// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "match_server/Match.h"
#include "save_client/Save.h"
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/ThreadFactory.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/transport/TSocket.h>
#include <thrift/TToString.h>

#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <vector>
#include <unistd.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace ::save_service;
using namespace ::match_service;
using namespace std;

struct Task{
    User user;
    string type;
};

struct MessageQueue{
    queue<Task> q;
    mutex m;
    condition_variable cv;
}message_queue;

class Pool{
    public:
        void save_result(int a, int b){
            printf("Match Result: %d %d\n", a, b);

            // std::shared_ptr<TTransport> socket(new TSocket("123.57.67.128", 9090));
            std::shared_ptr<TTransport> socket(new TSocket("123.57.67.128", 9090));
            std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
            std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
            SaveClient client(protocol);

            try {
                transport->open();
                // client.save_data("acs_14657", "1b6889b0", a, b);
                int res = client.save_data("acs_14657", "1b6889b0", a, b);
                if (!res) puts("success!");
                else puts("failed!");
                transport->close();
            } catch (TException& tx) {
                cout << "ERROR: " << tx.what() << '\n';
            }
        }

        bool check_match(uint32_t i, uint32_t j) {
            auto a = users[i], b = users[j];

            int dt = abs(a.score - b.score);
            int a_max_dif = wt[i] * 50;
            int b_max_dif = wt[j] * 50;

            return dt <= a_max_dif && dt <= b_max_dif;
        }


        void match(){
            for (uint32_t i = 0; i < wt.size(); i++)
                wt[i] ++;  // 等待秒数 + 1
            while (users.size() > 1){
                bool flag = true;
                for (uint32_t i = 0; i < users.size(); i++){
                    for (uint32_t j = i + 1; j < users.size(); j++){
                        if (check_match(i, j)){
                            auto a = users[i], b = users[j];
                            users.erase(users.begin() + j);
                            users.erase(users.begin() + i);
                            wt.erase(wt.begin() + j);
                            wt.erase(wt.begin() + i);
                            save_result(a.id, b.id);
                            flag = false;
                            break;
                        }
                    }
                    if (!flag) break;

                }
                if (flag) break;
            }
        }


        void add(User user){
            users.push_back(user);
            wt.push_back(0);
        }

        void remove(User user){
            for (uint32_t i = 0; i < users.size(); i++)
                if (users[i].id == user.id){
                    users.erase(users.begin() + i);
                    wt.erase(wt.begin() + i);
                    break;
                }
        }

    private:
        vector<User> users;
        vector<int> wt;  // 等待时间，单位 s
}pool;


class MatchHandler : virtual public MatchIf {
    public:
        MatchHandler() {
            // Your initialization goes here
        }

        /**
         * user: 添加的用户信息
         * info: 附加信息
         * 在匹配池中添加一个名用户
         * 
         * @param user
         * @param info
         */
        int32_t add_user(const User& user, const std::string& info) {
            // Your implementation goes here
            printf("add_user\n");

            // 加锁
            unique_lock<mutex> lck(message_queue.m);
            message_queue.q.push({user, "add"});
            message_queue.cv.notify_all();

            return 0;
        }

        /**
         * user: 删除的用户信息
         * info: 附加信息
         * 从匹配池中删除一名用户
         * 
         * @param user
         * @param info
         */
        int32_t remove_user(const User& user, const std::string& info) {
            // Your implementation goes here
            printf("remove_user\n");

            // 加锁
            unique_lock<mutex> lck(message_queue.m);
            message_queue.q.push({user, "remove"});
            message_queue.cv.notify_all();

            return 0;
        }

};

class MatchCloneFactory : virtual public MatchIfFactory {
    public:
        ~MatchCloneFactory() override = default;
        MatchIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) override
        {
            std::shared_ptr<TSocket> sock = std::dynamic_pointer_cast<TSocket>(connInfo.transport);
            /*
            cout << "Incoming connection\n";
            cout << "\tSocketInfo: "  << sock->getSocketInfo() << "\n";
            cout << "\tPeerHost: "    << sock->getPeerHost() << "\n";
            cout << "\tPeerAddress: " << sock->getPeerAddress() << "\n";
            cout << "\tPeerPort: "    << sock->getPeerPort() << "\n";
            */
            return new MatchHandler;
        }
        void releaseHandler(MatchIf* handler) override {
            delete handler;
        }
};

void consume_task(){
    while(true){

        unique_lock<mutex> lck(message_queue.m);
        if (message_queue.q.empty()){
            // message_queue.cv.wait(lck);
            lck.unlock();
            pool.match();
            sleep(1);
        }
        else {
            auto task = message_queue.q.front();
            message_queue.q.pop();
            lck.unlock();

            // do task
            if (task.type == "add") pool.add(task.user);
            else if (task.type == "remove") pool.remove(task.user);

        }
    }
}

int main(int argc, char **argv) {
    TThreadedServer server(
            std::make_shared<MatchProcessorFactory>(std::make_shared<MatchCloneFactory>()),
            std::make_shared<TServerSocket>(9090), //port
            std::make_shared<TBufferedTransportFactory>(),
            std::make_shared<TBinaryProtocolFactory>());


    cout << "Start Match Server" << endl;

    thread matching_thread(consume_task);

    server.serve();
    return 0;
}


```



```sh
g++ -c main.cpp
g++ *.o -o main -lthrift -pthread

git add main.cpp
git commit -m "match server:5.0 des-By introducing wt, different segment matching intervals are added"
```

| ./main | python3 client.py |
| ------ | ----------------- |
|        | add 1 1 1000      |
|        | add 2 2 2000      |



 

## 作业

创建好作业后，先进入文件夹`/home/acs/homework/lesson_6/`，当前目录的文件结构如下：

```sh
`-- thrift_lesson
    |-- game
    |   `-- src
    |-- match_system
    |   `-- src 
    |-- readme.md
    `-- thrift
        |-- match.thrift
        `-- save.thrift
```

0. 进入`thrift_lesson/match_system/src/`目录，用c`pp`实现课上的`match-server`和`save-client`逻辑。
   接口文件在`thrift_lesson/thrift/`中。
   实现后启动`server`，监听端口`9090`。
1. 进入`thrift_lesson/game/src/`目录，用`python3`实现课上的`match-client`逻辑。
   文件名和输入格式与课上内容相同。(两个复制[地址](https://git.acwing.com/yxc/thrift_lesson/)) 

- 服务端

```sh
cd ~/homework/lesson_6/thrift_lesson/
cd match_system/scr
thrift -r --gen cpp ../../thrift/match.thrift
mv gen-cpp/ match_server
rm match_server/Match_server.skeleton.cpp
thrift -r --gen cpp ../../thrift/save.thrift
mv gen-cpp/ save_client
rm save_client/Save_server.skeleton.cpp
# github.com 复制，改用户名，密码 `int res = client.save_data("", "", a, b);` 密码 md5sum(homework 4 getinfo)加密
# 修改 ip std::shared_ptr<TTransport> socket(new TSocket("123.57.47.211", 9090));
vim main.cpp
g++ -c main.cpp match_server/*.cpp save_client/*.cpp # 编译
g++ *.o -o main -lthrift -pthread  # 链接 thrift, thread以及本地.o文件
```

- 客户端

```sh
cd ~/homework/lesson_6/thrift_lesson/
cd game/src
thrift -r --gen py ../../thrift/match.thrift
mv gen-py/ match_client
rm match_client/match/Match-remote
# github.com 复制
vim client.py
```

- 运行

  ```sh
  ~/homework/lesson_6/thrift_lesson/match_system/src/main
  python3 ~/homework/lesson_6/thrift_lesson/game/src/client.py
  add 1 bob 1000
  add 2 alice 1200
  # 当 faild 时候检查 main.cpp 的ip, username, password(md5sum)
  # 测试时候需要开启 main
  homework 6 test
  ```

  
