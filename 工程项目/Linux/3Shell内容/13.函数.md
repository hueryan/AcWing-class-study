`bash` 中的函数类似于 `C/C++` 中的函数，但 `return` 的返回值与 `C/C++` 不同，返回的是 `exit code` ，取值为0-255，0表示正常结束。

如果想获取函数的输出结果，可以通过 `echo` 输出到 `stdout` 中，然后通过 `$(function_name)` 来获取 `stdout` 中的结果。

函数的 `return` 值可以通过 `$?` 来获取。

命令格式：

```sh
[function] func_name() {  # function关键字可以省略
    语句1
    语句2
    ...
}
```

## 不获取 `return` 值和 `stdout` 值

示例

```sh
func() {
    name=yxc
    echo "Hello $name"
}

func
```

输出结果：

```sh
Hello yxc
```

## 获取 `return` 值和 `stdout` 值

不写 `return` 时，默认 `return 0`。

示例

```sh
func() {
    name=yxc
    echo "Hello $name"

    return 123
}

output=$(func)
ret=$?

echo "output = $output"
echo "return = $ret"
```

输出结果：

```sh
output = Hello yxc
return = 123
```

## 函数的输入参数

在函数内，`$1` 表示第一个输入参数，`$2` 表示第二个输入参数，依此类推。

注意：函数内的 `$0` 仍然是文件名，而不是函数名。

示例：

```sh
func() {  # 递归计算 $1 + ($1 - 1) + ($1 - 2) + ... + 0
    word=""
    while [ "${word}" != 'y' ] && [ "${word}" != 'n' ]
    do
        read -p "要进入func($1)函数吗？请输入y/n：" word
    done

    if [ "$word" == 'n' ]
    then
        echo 0
        return 0
    fi  

    if [ $1 -le 0 ] 
    then
        echo 0
        return 0
    fi  

    sum=$(func $(expr $1 - 1))
    echo $(expr $sum + $1)
}

echo $(func 10)
```

输出结果：

```sh
55
```

为什么只输出55不输出其他的值，只要在`echo`函数后面有`$`,这个`$` 就会截获掉`stdout`里的值，使得`echo`找不到`stdout`里的数据从而不能输出，在递归`往回调用`的过程中上一层的`echo`会被这一层的`sum=$(func $(expr $1 - 1))`中的第一个`$`捕获从而没有输出，而最后一层的`echo`会被函数外的`echo $(func 10)`的`$`捕获因此是函数外的`echo`输出的55。如果你把函数外的`echo $(func 10)`改成`func 10`就是最后一层递归`echo $(expr $sum + $1)`输出的55.

## 函数内的局部变量

可以在函数内定义局部变量，作用范围仅在当前函数内。

可以在递归函数中定义局部变量。

命令格式：

```sh
local 变量名=变量值
```

例如：

```sh
#! /bin/bash

func() {
    local name=yxc
    echo $name
}
func

echo $name
```

输出结果：

```sh
yxc

```

第一行为函数内的name变量，第二行为函数外调用name变量，会发现此时该变量不存在。